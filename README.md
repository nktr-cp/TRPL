## [The Rust Programming Language](https://doc.rust-jp.rs/book-ja/) を読む

### 1章: 事始め
#### 1-1. インストール
- `rustup`: Rustのバージョンと関連ツールの管理
#### 1-2. Hello, World!
- ファイルのコンパイルは`rustc main.rs`で行える
- !で終わるもの(`function_name!()`)ではマクロが呼び出されている
#### 1-3. Hello, Cargo!
- Cargo: Rustのビルドシステム、パッケージマネージャー
- `cargo new project_name`を実行すると、`Cargo.toml`および`src`ディレクトリが作成される
- `Cargo.toml`はTOML形式で書かれており、コンパイルのための設定情報や、プロジェクトの依存を列挙する
- Rustのコードのパッケージを、**クレート**(**crate**)という
- プロジェクトのビルドは`cargo build`、実行ファイルの実行までをまとめて実行するには`cargo run`とする
- `cargo check`とすると、コンパイルできるかどうかのチェックを高速に行う

### 2章: 数当てゲームのプログラミング
- Rustはデフォルトで標準ライブラリに定義されているアイテムの中のいくつかを全てのプログラムのスコープに取り込む(**prelude**)
- 使いたい型がpreludeにない時は、`use`文で明示的にスコープに入れる (`std::io`はユーザとの入出力の処理に関しての機能を持つ)
- 変数を作る時は`let`文を使う
- 変数はデフォルトでは不変(immutable)になる。可変(mutable)にするには、変数名の前に`mut`をつける
- 等号記号(`=`)はRustに、変数を何かに束縛したいことを伝える効果がある
- `String::new`は、`String`型の新しいインスタンスを返す関数
- `String`は標準ライブラリにより提供される文字列型で、サイズが拡張なのうな、UTF-8でエンコードされたテキスト片
- `::`構文は、型に関しての関連関数であることを示す (`String::new`ならば、`new`は`String`に対して実装されているもの)
- `&`は引数が参照であることを示す、ここで参照もデフォルトでイミュータブルであり、`&mut var_name`のようにして書く必要がある点に注意
- `read_line`メソッドは、ユーザが入力した文字列に加え、同時に他の値も返している (この場合では`io::Result`)
- `Result`型は列挙型(enum)で、列挙子として`Ok`および`Err`を持つ
- `expect`メソッドを使用することで、`io::Result`インスタンスが`Err`の場合はプログラムをクラッシュさせ、`Ok`列挙子が保持する戻り値を取り出してその値だけを返してくれるようになる
- `println!`マクロのプレースホルダーは`{}`で書く (Pythonなら`{} + .format()`)
- Cargoはセマンティックバージョンを理解していて、`Cargo.toml`に外部クレートのバージョンを記述すると、そのバージョンと互換性のある公開APIを持つようになる
- `Cargo.lock`ファイルには依存関係のバージョンが記載されていて、これによりクレートのアップデートがあってもビルドに再現性を持たせられる
- クレートをアップグレードしたい場合は、cargo update`とする。`
- `match`式は複数のアームで構成され、各アームはマッチさせるパターンと、`match`に与えられた値がそのアームのパターンにマッチした時に実行されるコードいより構成される
- Rustでは変数のシャドウイングが許されていて、型の変換を行う際によく登場する
- 変数名の後に`:`をつけることで変数の型に注釈をつけることができる
- 無限ループの作成には`loop`キーワードを作成

### 3章: 一般的なプログラミングの概念
#### 3-1. 変数と可変性
- 定数を宣言したい時には、`let`キーワードの代わりに`const`キーワードを使用し、**必ず**型の注釈が必要
- 定数は定数式にしかセットできず、関数呼び出し結果や実行時に評価されるzたいをセットすることはできない
- 定数の命名規則は、すべて大文字で記述しアンダースコアで単語区切りする

#### 3-2. データ型
- Rustは静的型付け言語なので、複数の方が推論される可能性がある場合には型注釈を付けないとコンパイルエラーになる
- Rustでのスカラー型は、整数、浮動小数点数、論理値、文字の4つ
##### 整数型
| 大きさ | 符号付き | 符号なし |
|:----------:|:-----------:|:------------:|
| 8-bit      | i8          | u8           |
| 16-bit     | i16         | u16          |
| 32-bit     | i32         | u32          |
| 64-bit     | i64         | u64          |
| arch       | isize       | usize        |

- 整数リテラルは、接頭辞として16進数で`0x`、8進数で`0o`、2進数で`0b`、バイト(`u8`)で`b`があり、接尾辞として見た目の区切り記号として`_`をつけることができる

##### 浮動小数点型
- 演算速度と精度の兼ね合いから`f64`が基準系になっている
- 例えば、`let x = 2.0;`では、`f64`型が割り当てられる

##### 論理値型
- 型名は`bool`と指定し、`true`と`false`のいずれかの値を取る
- `if`式において主に用いられる

##### 文字型
- アルファベット型には`char`型が用意、シングルクオートで囲む
- ユニコードのスカラー値を表しており、asciiよりは遥かに多くの文字を表現可能(第8章で詳細)

##### 複合型
- 複合型を用いることで、複数の値を一つの方にまとめることができる
- 基本的な複合型としてはタプルと配列が存在
- タプルは丸括弧の中に`,`区切りの値リストを書くことで生成され、タプル内の値は異なる型でもよい
- タプルは1つの複合要素と考えられ、変数はタプル全体に束縛される
- 個々の値を取り出すには、パターンマッチングを使用して分解することができる(これを**分配**という)
- このほかに、アクセスしたい値の番号をピリオドに続けて書くことでタプルの要素に直接アクセスすることができる

##### 配列型
- Rustの配列は固定長で、スタックに確保される
- 可変長配列を被用したい場合はベクタ型を使用すればよい(第8章)
- 配列の型は角括弧の中に要素の方とセミコロン、配列の要素数を与える (例: `let a: [i32; 2] = [42,-42];`)
- `let a = [3; 5];`のように書くことで、各要素に同じ値をもつように初期化することができる (例では3という値を5つもつ配列)
- 配列要素へのアクセスは、`array[index]`のようにして行う
- 配列外参照を行うと実行時エラーとなり、この時Rustでは**パニック**するという

#### 3.3. 関数
- Rustの関数と変数の命名規則は、スネークケースにするのが慣例
- 関数定義は`fn`キーワードで始まり、関数がmain関数に対して上下どちらで定義されているかは関係なく動作する
- 関数シグニチャでは引数の型注釈が必須
- (review: 文は何らかの動作をして値を返さない命令、式は結果値に評価される)
- Rustでは変数の生成における値の代入は文なので、`let x = (let y = 6);`はコンパイルエラー
- この動作はC言語などとは異なる
- Rustにおいて式は終端にセミコロンを含まず、式の終端にセミコロンをつけてしまうとその処理は文になってしまう
- 戻り値のある関数では、戻り値の型を`->`の後に書いて宣言する
- 関数の戻り値は関数本体ブロックの最後の式の値と同義で、`return`キーワードを用いて早期リターンして値を指定することもできるが、多くの関数では最後の式を暗黙的に返すようにされる

#### 3.4. コメント
- Rustではコメントは2連スラッシュで始め、行の終わりまで続く
- コメントが複数行にまたがる場合は各行に`//`を含めつ必要がある

#### 3.5. 制御フロー
- `if`キーワードの後には条件式を続け、その直後に波括弧で囲んで配置する
- 条件式と紐づけられる一連のコードは、アームと呼ばれることがある
- `if`文の条件式は`bool`型でなければならない
- 複数の条件を扱いたい時は`else if`を使用するが、コードが読みにくくなった場合には`match`文を使用することを検討する
- `if`は**式**である (例: `let x = if condition { 5 } else { 6 }`)
- ただし、`if`と`else`アームでの型は互換性があるように選ばなければいけない
- 無限ループを書きたい時は`loop`キーワードを使用するとよい
- ループにはラベルがつけられ、`break`にこれを渡すことができる
- 条件付きの無限ループを呼びたい時は`while`ループを使用するとよい
- `for`は要素ごとにイテレーションする範囲`for`が可能 (例: `for elem in array {}`)で、安全性と簡潔さから推奨の書き方になっている
- `Range`型を使用することで高度な`for`の処理が可能になる (例: `rev`メソッド)

### 4章: 所有権を理解する
#### 4.1. 所有権とは？
- Rustの各値は、所有者と呼ばれる変数と対応し、いかなる場合も所有者は1つ
- 所有者がスコープから外れると、値は破棄される
- メモリの返還は`drop`関数により行われ、スコープを抜けると自動的にこれが呼び出される
- ヒープに確保された値を他の変数に代入しようとすると、ムーブ代入演算がよばれて所有権が移動、元々値を保持していた変数を参照するとコンパイルエラーになる
- deep copyが必要な場合には`clone`メソッドを使用する必要があるが、当然これは実行コストが比較的高い
- スタックにあるデータは、`Copy`トレイトに適合している場合、代入後も古い変数が使用可能になる
- 一般に単純なスカラー値の集合は`Copy`であり、メモリ確保されるリソースは`Copy`ではない (コピーのコストが大きくないため)

#### 4.2. 参照と借用
- 関数呼び出しの引数にしても所有権は移動してしまう
- これは値の所有権をもらう代わりに引数としてオブジェクトへの**参照**を取るようにすると解消される、この場合参照がスコープを抜けてもドロップされない
- 関数の引数に参照を取ることを、**借用**という
- 可変な参照を取る時は引数を渡す時点で、`&mut arg`のように書く、関数側も`(arg: &mut type)`のように宣言しておく
- 任意のタイミングで、一つの可変参照か不変な参照いくつでものどちらかを行うことができる
- 可変な参照は、特定のスコープで特定のデータに対しては1つしか持てない、これはデータレースを防ぐため
- また、不変な借用をしている間に可変な借用をすることはデータ競合の原因となり、認められない
- ダングリングポインタ: 他人に渡されてしまった可能性のあるメモリを指すポインタ、その箇所へのポインタを保持している間にメモリを解放してしまうことで発生
- Rustではコンパイラが参照がダングリング参照になることが絶対ないように保証されている
- 参照はつねに有効でなければならず、有効でなければコンパイルエラーとなる

#### 4.3. スライス型
- `[starting_index..ending_index]`と指定することでスライスが生成できる
- `starting_index`はスライスの最初の位置、`ending_index`はスライスの終端位置よりも1大きい値になる
- Rustの範囲記法`..`で、最初の番号(`0`)から始めたければ、二連ピリオドの前に値を置かないようにすればよく、末尾までのスライスを作るには最後の数字を書かなければよい (両方の値を省略すれば全体のスライスを得られる)
- 文字列スライスではマルチバイト文字の途中でスライスを生成しようとするとエラーになるので注意
- 文字列リテラルは、バイナリに埋め込まれた特定の位置を指すスライスとして書かれる、ゆえに不変な参照になっている (型: `&str`)
- 文字列以外のデータの型配列に対しても配列が取れて、この時の型は`&[type]`となる
